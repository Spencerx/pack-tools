#!/bin/sh

#TODO: perhaps there's easier way to do this with osc vc
#TODO: we can't handle filenames with spaces inside

function usage {
	printf "usage: $0 [ -p package_name ] [ -c new_changelog_entry_file | -n keep_as_filename ]\n"
	exit 1
}

function cleanup {
	rm -f $NEW_CHANGES
	if [ -n "$TEMP_ENTRY_FILE" ]; then
		rm -f $ENTRY_FILE
	fi
}

trap cleanup SIGINT SIGTERM

while getopts "p:c:n:" opt; do
	case "$opt" in
	p) # package name
		PKG="$OPTARG"
		;;
	c) # file with the new changelog entry
		ENTRY_FILE="$OPTARG"
		;;
	n) # name for the new changelog entry file
		KEEP_NEW_ENTRY="$OPTARG"
		;;
	\?) # unknown flag
		usage
	esac
done

if [ -z "$PKG" ]; then
	PKG=$(basename $PWD)
fi

CHANGES=$PKG.changes

# if no package name was specified on the command line,
# we take the first .changes file we can find
if [ ! -s "$CHANGES" ]; then
	CHANGES=$(ls -1 *.changes | head -n 1)
	printf "Using $CHANGES as .changes file. You can override it with -p.\n"
fi

if [ ! -s "$CHANGES" ]; then
	printf "Can't find .changes file. Specify package name with -p.\n"
	exit 1
fi

# create a temporary file if we didn't get a name on command line
if [ -z "$ENTRY_FILE" ]; then
	ENTRY_FILE=$(mktemp)
	TEMP_ENTRY_FILE="yes"

	# osc vc appends .changes to the filename if it doesn't end with it
	osc vc $ENTRY_FILE
	#TODO check whether $ENTRY_FILE already ends with .changes
	ENTRY_FILE=$ENTRY_FILE.changes
fi

if [ ! -s "$ENTRY_FILE" ]; then
	printf "New changelog entry is empty\n"
	exit 1
fi

NEW_CHANGES=$(mktemp)
cat $ENTRY_FILE $CHANGES > $NEW_CHANGES
mv $NEW_CHANGES $CHANGES

# rename the entry file
if [ -n "$KEEP_NEW_ENTRY" ]; then
	mv -f $ENTRY_FILE $KEEP_NEW_ENTRY
fi

cleanup
