#!/bin/sh

#TODO: mktemp probably useless with osc vc
function usage {
	printf "usage: $0 [ -p package_name ] [ -c new_changelog_entry_file ] [ -n keep_as_filename ]\n"
	exit 1
}

function cleanup {
	rm -f $NEW_CHANGES
}

trap cleanup SIGINT SIGTERM

while getopts "p:c:n:" opt; do
	case "$opt" in
	p) # package name
		PKG="$OPTARG"
		;;
	c) # file with the new changelog entry
		NEW_ENTRY_FILE="$OPTARG"
		;;
	n) # name for the new changelog entry file
		KEEP_NEW_ENTRY="$OPTARG"
		;;
	\?) # unknown flag
		usage
	esac
done

if [ -z "$PKG" ]; then
	PKG=$(basename $PWD)
fi

CHANGES=$PKG.changes
# if no package name was specified on the command line,
# take the first .changes file we can find
if [ ! -s "$CHANGES" ]; then
	CHANGES=$(ls -1 *.changes | head -n 1)
	printf "Using $CHANGES file. You can override it with -p.\n"
fi

if [ ! -s "$CHANGES" ]; then
	printf "Can't find .changes file. Specify package name with -p.\n"
	exit 1
fi

if [ -z "$NEW_ENTRY_FILE" ]; then
	# TODO: this is silly
	NEW_ENTRY_FILE=$(basename $(mktemp -u))
	NEW_ENTRY_FILE_CREATED="yes"
	osc vc $NEW_ENTRY_FILE
	RANDOM_ENTRY_FILE="yes"

	# osc vc appends ".changes" to the filename
	NEW_ENTRY_FILE=$NEW_ENTRY_FILE.changes
fi

if [ ! -s $NEW_ENTRY_FILE ]; then
	printf "New changelog entry is empty\n"
	exit 1
fi

NEW_CHANGES=$(mktemp)
cat $NEW_ENTRY_FILE $CHANGES > $NEW_CHANGES
mv $NEW_CHANGES $CHANGES

# rename the entry file if desired
if [ -n "$KEEP_NEW_ENTRY" ]; then
	mv $NEW_ENTRY_FILE $KEEP_NEW_ENTRY
elif [ -n "$NEW_ENTRY_FILE_CREATED" ]; then
	rm -f $NEW_ENTRY_FILE
fi

cleanup
